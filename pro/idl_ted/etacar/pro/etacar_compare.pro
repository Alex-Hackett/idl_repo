
pro etacar_compare_echelle,id1,id2,flip2=flip2,eso=eso,xshift=xshift, $
	wide=wide
;
; routine to compare echelle extended source extractions of etacar
; generated by process.pro
;
;
; INPUTS:
;	id1,id2 - observations ids
; OPTIONAL KEYWORD INPUTS:
;	/flip2 - flip second observation in y-direction
;	/wide - for wide screen displays
;
	common etacar_cludge,warray,orders,rsave,gsave,bsave
; read files
;
	two_files = n_elements(id2) gt 0
	if keyword_set(eso) then begin
;
; ESO data
;
		read_eso,id1,h1,w1,f1,xshift=xshift
		s = size(f1) & ns1 = s(1) & nl1 = s(2)
		if two_files then begin
			read_eso,id2,h2,w2,f2
			s = size(f2) & ns2 = s(1) & nl2 = s(2)
;
; shift second to the first
;
			diff1 = w1(1)-w1(0)
			diff2 = w2(1)-w2(0)
			if abs(diff2-diff1) lt 0.000001 then begin
			    ishift = round((w2(0)-w1(0))/diff1)
			    if ishift ne 0 then begin
				f2 = shift(f2,ishift)
				if ishift lt 0 then f2((ns2+ishift-1)>0:*,*)=0 $
					       else f2(0:ishift<(ns2-1),*) = 0
			    end
			    if ns2 lt ns1 then f2 = [f2,fltarr(ns1-ns2,nl2)]
			    if ns2 gt ns1 then f2 = f2(0:ns1-1,*)
			  end else begin
			    new_f2 = fltarr(ns1,nl2)
			    for i=0,nl2-1 do begin
			    	linterp,w2,f2(*,i),w1,fint
				new_f2(0,i) = fint
			    end
			    f2 = temporary(new_f2)
			end
			w2 = w1
			ns2 = ns1
		end
;
; split into orders
;
		eso_split,m1,w1,f1
		if two_files then eso_split,m2,w2,f2
	    end else begin
;
; STIS data
;
	    	read_extended,id1,h1,m1,w1,f1
	    	if two_files then begin
			read_extended,id2,h2,m2,w2,f2
			if strtrim(sxpar(h1,'opt_elem')) ne $
			   strtrim(sxpar(h2,'opt_elem')) then begin
			    print,'Both observations must be the same' + $
			    	' optical element'
			    retall
			end
	    	end
	end
;
; match orders
;
	if (two_files) and (not keyword_set(eso)) then begin
		match,m1,m2,sub1,sub2
		m1 = m1(sub1)
		w1 = w1(*,sub1)
		w2 = w2(*,sub2)
		f1 = f1(*,*,sub1)
		f2 = f2(*,*,sub2)
	end
	norders = n_elements(m1)
;
; wavelength shift to nearest hires pixel
;
	if two_files and (not keyword_set(eso)) then begin
		wc1 = w1(1024,*)
		wc2 = w2(1024,*)
		dx = (wc2-wc1)/(wc1-w1(1023,*))
		dx = round(median(dx))
		n = (2048-abs(dx))/2*2
		if dx gt 0 then begin
			w1 = w1(dx:dx+n-1,*)
			w2 = w2(0:n-1,*)
			f1 = f1(dx:dx+n-1,*,*)
			f2 = f2(0:n-1,*,*)
		    end else begin
		        dx = -dx
			w2 = w2(dx:dx+n-1,*)
			w1 = w1(0:n-1,*)
			f2 = f2(dx:dx+n-1,*,*)
			f1 = f1(0:n-1,*,*)
		end
	end
;
; bin to lores in the dispersion direction
;
	s = size(f1) & ny = s(2) & nx = s(1)
 	if not keyword_set(eso) then begin
	 	nx = nx/2
		w1 = rebin(w1,nx,norders)
		f1 = rebin(f1,nx,ny,norders)
		if two_files then begin
			w2 = rebin(w2,nx,norders)
			f2 = rebin(f2,nx,ny,norders)
		end
	end
;
; create wavelength overlay
;
	window, 10, xs=nx, ys=norders*(ny+20),/pixmap

	if strpos(sxpar(h1,'opt_elem'),'H') gt 1 then delta=1 else delta=2

	for i=0,norders-1 do begin
	    w = w1(*,i)
	    minw = (ceil(min(w))+1)/2*2
	    maxw = fix(max(w))
	    ypos = i*(ny+20)
	    for j=minw,maxw do begin
		tabinv,w,j,x & x = round(x(0))
		plots,[x,x],[ypos+15,ypos+20],/dev,color=1
	    end
	    for j=minw,maxw,delta do begin
		tabinv,w,j,x & x = round(x(0))
		xyouts,x,ypos+5,strtrim(j,2),/dev,align=0.5,color=1
		for k=1,9 do begin
			tabinv,w,j+k/10.0*delta,x & x = round(x(0))
			plots,[x,x],[ypos+17,ypos+20],/dev,color=1
		end
	    xyouts,2,ypos+8,strtrim(m1(i),2),/dev,color=1
	    end
	end
	overlay = tvrd()
	wdelete,10
;
; create images
;
	maxf = max(f1)
	if two_files then maxf = maxf>max(f2)
	overlay = overlay*maxf

	image1 = overlay
	for i=0,norders-1 do image1(0,i*(ny+20)+20) = f1(*,*,i)

	if two_files then begin
	    image2 = temporary(overlay)
	    for i=0,norders-1 do begin
		if keyword_set(flip2) then image2(0,i*(ny+20)+20) = $
							reverse(f2(*,*,i),2) $
				      else image2(0,i*(ny+20)+20) = f2(*,*,i)
	    end
	end
;
; display images
;
	orders = m1
	warray = w1

	if two_files then begin
		if keyword_set(wide) then xsize = 800 else xsize = 550
		xctv2,image1,image2,h1,h2,y_scroll_size=400, $
				x_scroll_size=xsize
	   end else begin
		if keyword_set(wide) then xsize = 1600 else xsize = 1200
	   	xctv,image1,h1,y_scroll_size=470, $
		     		x_scroll_size=n_elements(image1(*,0))<xsize
	end
end
;
; routine to read and normalize UMN files
;
pro eta_car_read_umn,file,f,h,w,normalize=normalize,writenorm=writenorm, $
	subtract=subtract
;
; read data
;
	fits_read,file,f,h
	w0 = sxpar(h,"CRVAL1")
	wc = sxpar(h,"CRPIX1")
	dw = sxpar(h,"CD1_1")
	dm = sxpar(h,"NAXIS1")
	w = w0 + ((findgen(dm)+1-wc))*dw
	print,file + ' Read'
;
; normalize between specified wavelength range
;
	if n_elements(normalize) gt 1 then begin
		good = where((w ge normalize(0)) and (w le normalize(1)),ngood)
		if ngood lt 1 then begin
			print,'Invalid value of normalize specfied'
			print,'W Range for files is ',min(w),max(w)
			retall
		end
		index1 = min(good)
		index2 = max(good)
		normvalue = total(f(index1:index2,*),1)/ngood
		s = size(f) & ns = s(1) & nl = s(2)
		if keyword_set(subtract) then begin
			for i=0,nl-1 do f(*,i) = f(*,i)-normvalue(i)
			filetype = 'sub'
			print,'Average flux between wavelengths', $
				normalize(0:1),' subtracted'
		    end else begin
			if max(normvalue) le 0 then begin
				print,'Non-positive normalization range'
				retall
			end
			bad = where(normvalue lt max(normvalue)*0.001,nbad)
			if nbad gt 0 then normvalue(nbad) = 1.0
			for i=0,nl-1 do f(*,i) = f(*,i)/normvalue(i)
			print,'Flux normalized between wavelengths',normalize(0:1)
			filetype = 'norm'
		end
;
; write normalized file
;
		if keyword_set(writenorm) then begin
			fdecomp,file,disk,dir,name
			name = name+'_'+filetype+'.fits'
			fits_open,name,fcb2,/write
			fits_open,file,fcb
			fits_read,fcb,d,h,exten=0
			sxaddpar,h,'wnorm1',normalize(0)
			sxaddpar,h,'wnorm2',normalize(1)
			fits_write,fcb2,0,h
			fits_read,fcb,d,h,exten=1
			fits_write,fcb2,f,h
			fits_read,fcb,dq,h,exten=2
			fits_write,fcb2,dq,h
			fits_read,fcb,err,h,exten=3
			if not keyword_set(subtract) then $
				for i=0,nl-1 do err(*,i) = err(*,i)/normvalue(i)
			fits_write,fcb2,err,h
;			fits_read,fcb,mask,h,exten=4
;			fits_write,fcb2,mask,h
			fits_close,fcb
			fits_close,fcb2
			print,'Normalized file '+name+' written'
		end
	end
end
pro etacar_compare_ccd,id1,id2,flip2=flip2,nlines=nlines,lores=lores, $
	mires=mires,compare=compare,wide=wide,normalize=normalize, $
	writenorm=writenorm,subtract=subtract
;
;
;
; INPUTS:
;	id1,id2 - observations ids
; OPTIONAL KEYWORD INPUTS:
;	flip2 - flip second observation in y-direction
;
	common etacar_cludge,warray,orders,rsave,gsave,bsave

	if n_elements(nlines) eq 0 then nlines = 500
	etype = 'HIRES'
	if keyword_set(MIRES) then etype = 'MIRES'
	if keyword_set(LORES) then etype = 'LORES'
;
; read UMN file
;
	if datatype(id1) eq 'STR' then begin
		location = getenv('ETACAR_UMN')
		file1 = (findfile(location + id1))[0]
		if file1 eq '' then begin
			print,'File '+id1+' not found in ETACAR_UMN='+location
			retall
		end
		eta_car_read_umn,file1,f1,h1,w1,normalize=normalize, $
				writenorm=writenorm,subtract=subtract
		sxaddpar,h1,'entry',id1
;
; find GSFC reduction to match UMN reduction
;
		if keyword_set(compare) then begin
		    nw2 = n_elements(w1)/2
		    nl = n_elements(f1(0,*))
		    w1 = rebin(w1(0:nw2*2-1),nw2)
		    f1 = rebin(f1(0:nw2*2-1,*),nw2,nl)*2
		    dbopen,'stislog'
		    list = dbfind('rootname='+strtrim(sxpar(h1,'rootname'))+ $
		    		  ',filename=raw')

		    if list(0) lt 1 then begin
		    	print,'No matching stislog entry found for '+id1
			retall
		    endif
		    etype = 'MIRES'
		    id2 = list(0)
		end
		goto,readfile2
	end
;
; read files
;

	for i=1,9 do begin
		location = getenv('ETACAR_'+etype+'_'+strtrim(i,2))
		if location eq '' then break
		file1 = (findfile(location + '/*/'+etype+'/save_calstis_'+ $
					strtrim(id1,2)+'.bin'))[0]
		if file1 ne '' then goto,found1
	end
	print,'unable to find file' + $
			'save_calstis_'+strtrim(id1,2)+'.bin'
	retall
found1:
	print,file1
	restore,file1

	w1 = w
	f1 = f
	h1 = h
	m1 = 1
	sxaddpar,h1,'entry',id1

readfile2:
	two_files = n_elements(id2) gt 0
	if two_files then begin

	    if datatype(id2) eq 'STR' then begin
		location = getenv('ETACAR_UMN')
		file2 = (findfile(location + id2))[0]
		if file2 eq '' then begin
			print,'File '+id2+' not found in ETACAR_UMN='+location
			retall
		end
		eta_car_read_umn,file2,f2,h2,w2,normalize=normalize, $
			writenorm=writenorm,subtract=subtract
		sxaddpar,h2,'entry',id2
		goto,done_reading
	    end

	    for i=1,9 do begin
		location = getenv('ETACAR_'+etype+'_'+strtrim(i,2))
		if location eq '' then break
		file2 = (findfile(location + '/*/'+etype+'/save_calstis_'+ $
					strtrim(id2,2)+'.bin'))[0]
		if file2 ne '' then goto,found2
	    end
	    print,'unable to find file' + $
			'save_calstis_'+strtrim(id2,2)+'.bin'
	    retall
found2:
	    print,file2
	    restore,file2
	    w2 = w
	    f2 = f
	    m2 = 1
	    h2 = h
	    sxaddpar,h2,'entry',id2
	end
done_reading:

;
; trim size
;
	if n_elements(nlines) eq 0 then nlines = 2000
	s = size(f1) & nl1 = s(2)
	nlines = nlines<nl1
	if two_files then begin
		s = size(f2) & nl2 = s(2)
		nlines = nlines<nl2
	end
	if nl1 gt nlines then f1 = f1(*,nl1/2-nlines/2:nl1/2+nlines/2-1)
	if two_files then begin
		if nl2 gt nlines then f2 = f2(*,nl2/2-nlines/2:nl2/2+nlines/2-1)
	end

;
; wavelength shift to nearest pixel
;
	if two_files then begin
		nw1 = n_elements(w1)
		nw2 = n_elements(w2)
		wc1 = w1(nw1/2)
		wc2 = w2(nw2/2)
		dx = round((wc2-wc1)/(wc1-w1(nw1/2-1)))
		n = ((nw1<nw2)-dx)/2*2
		if dx gt 0 then begin
			w1 = w1(dx:dx+n-1)
			w2 = w2(0:n-1,*)
			f1 = f1(dx:dx+n-1,*)
			f2 = f2(0:n-1,*)
		    end else begin
		        dx = -dx
			w2 = w2(dx:dx+n-1)
			w1 = w1(0:n-1)
			f2 = f2(dx:dx+n-1,*)
			f1 = f1(0:n-1,*)
		end
	end else n = n_elements(w1)

;
;
	s = size(f1) & ny = s(2) & nx = s(1)
;
; begin oversampled data in wavelength
;
	if nx gt 1200 then begin
       		nx = nx/2
       		w1 = rebin(w1,nx)
       		f1 = rebin(f1,nx,ny)
       		if two_files then begin
		       w2 = rebin(w2,nx)
		       f2 = rebin(f2,nx,ny)
      		end
	end
	n = nx
;
; create wavelength overlay
;
	ny = ny + 40	;add space for wavelength scales
	window, 10, xs=n, ys=ny,/pixmap

	delta=20

	w = w1
	minw = (ceil(min(w))+1)/2*2
	maxw = fix(max(w))
	for j=minw,maxw,delta do begin
		tabinv,w,j,x & x = round(x(0))
		xyouts,x,5,strtrim(j,2),/dev,align=0.5,color=1
		xyouts,x,ny-14,strtrim(j,2),/dev,align=0.5,color=1
		plots,[x,x],[15,23],/dev,color=1
		plots,[x,x],ny-[15,23],/dev,color=1
		for k=1,9 do begin
			tabinv,w,j+k/10.0*delta,x & x = round(x(0))
			tabinv,w,j+k/10.0*delta,x & x = round(x(0))
			plots,[x,x],[17,20],/dev,color=1
			plots,[x,x],ny-[17,20],/dev,color=1
		end
	end
	overlay = tvrd()
	wdelete,10
;
; create images
;
	maxf = max(f1)
	if two_files then maxf = maxf>max(f2)
	overlay = overlay*maxf

	image1 = overlay
	image1(0,20) = f1

	if two_files then begin
	    image2 = temporary(overlay)
	    if keyword_set(flip2) then image2(0,20) = reverse(f2,2) $
				  else image2(0,20) = f2
	end
;
; display images
;
	orders = 1
	warray = w1

	if two_files then begin
		if keyword_set(wide) then begin
			xctv2,image1,image2,h1,h2,y_scroll_size=400<ny, $
				pan_limits=[500,256],x_scroll_size=750
		    end else begin
			xctv2,image1,image2,h1,h2,y_scroll_size=400<ny, $
				pan_limits=[350,256],x_scroll_size=560
		end
	  end else begin
		if keyword_set(wide) then xsize = 1600 else xsize = 1200
	  	xctv,image1,h1, $
		     		x_scroll_size=n_elements(image1(*,0))<xsize, $
				y_scroll_size=480<ny
	end
end

pro etacar_compare,id1,id2,flip=flip,nlines=nlines,lores=lores,mires=mires, $
		compare=compare,eso=eso,xshift=xshift,wide=wide, $
		normalize=normalize,writenorm=writenorm,subtract=subtract

	ccd = 0
	if datatype(id1) eq 'STR' then begin
		if keyword_set(eso) then ccd = 0 else ccd = 1
	    end else begin
		dbopen,'stislog'
	    	dbext,id1,'opt_elem',grating
	    	if (strmid(grating(0),0,1) ne 'E') then ccd = 1
	end

	if ccd then begin
	    	etacar_compare_ccd,id1,id2,flip=flip,nlines=nlines, $
	    			lores=lores,mires=mires,compare=compare, $
				wide=wide,normalize=normalize, $
				writenorm=writenorm,subtract=subtract
	    end else begin
		 etacar_compare_echelle,id1,id2,flip=flip,eso=eso, $
				xshift=xshift,wide=wide
	end
end
